<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>DocsWASM</title>
    <base href="/" />
    <!--<link href="DocsWASM.Client.styles.css" rel="stylesheet" />-->
    <link href="manifest.json" rel="manifest" />
    <link rel="apple-touch-icon" sizes="512x512" href="icon-512.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

    <script src="_framework/blazor.webassembly.js" autostart="true"></script>
    <script src="lib/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="lib/mupdf/mupdf.js"></script>

    <link href="lib/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
    <link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="lib/style.css" rel="stylesheet">
</head>


<body>

    <div id="app">
        <!--<div class="progress">
            <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100" style="width: var(--blazor-load-percentage, 0%)">
                <div class="loading-text"></div>
            </div>
        </div>-->
        <img class="d-block mx-auto my-4 h-100 w-100 px-2" src="/img/logo/docasLargeTransparency.png" style="object-fit:scale-down" />
        <svg class="loading-progress d-block m-0 mx-auto">
            <circle r="40%" cx="50%" cy="50%" />
            <circle r="40%" cx="50%" cy="50%" />
        </svg>
    </div>
    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>
    <script>navigator.serviceWorker.register('service-worker.js');</script>
    <script>
        var offCanvas;
        var mupdf = undefined;

        async function loadMupdf() {
            var createMuPdf = require('mupdf-js');
            mupdf = await createMuPdf.createMuPdf();
        }

        function disposeMupdf() {
            mupdf = undefined;
        }

        function blazorFocusElement(element) {
            if (element instanceof HTMLElement) {
                element.focus({
                    preventScroll: true
                });
            }
        }

        function freeObjectsUrls(urls) {
            for (let i = 0; i < urls.length; i++) {
                URL.revokeObjectURL(urls[i]);
            }
        }

        function getObjectsUrls(datasmimes) {
            const urls = [];
            for (let i = 0; i < datasmimes.length; i++) {
                var blob = new Blob([datasmimes[i].data], { type: datasmimes[i].type });
                urls.push(URL.createObjectURL(blob));
            }
            return urls;
        }

        async function convert(data) {
            const svgs = [];
            const doc = mupdf.load(data);
            const pages = await mupdf.countPages(doc);
            for (let i = 1; i <= pages; i++) {
                svgs.push([mupdf.drawPageAsSVG(doc, i), mupdf.getPageText(doc, i)]);
            }
            mupdf.freeDocument(doc);
            return svgs;
        }

        function offCanvasInit(id) {
            offCanvas = new bootstrap.Offcanvas(document.getElementById(id));
        }

        function scrollToElement(elementId) {
            var element = document.getElementById(elementId);
            element.scrollIntoView();
        }

    </script>
    <!--<script type="module">
        import { BrotliDecode } from './decode.min.js';
        Blazor.start({
            loadBootResource: function (type, name, defaultUri, integrity) {
                if (type !== 'dotnetjs' /*&& location.hostname !== 'localhost'*/) {
                    return (async function () {
                        const response = await fetch(defaultUri + '.br', { cache: 'no-cache' });
                        if (!response.ok) {
                            throw new Error(response.statusText);
                        }
                        const originalResponseBuffer = await response.arrayBuffer();
                        const originalResponseArray = new Int8Array(originalResponseBuffer);
                        const decompressedResponseArray = BrotliDecode(originalResponseArray);
                        const contentType = type ===
                            'dotnetwasm' ? 'application/wasm' : 'application/octet-stream';
                        return new Response(decompressedResponseArray,
                            { headers: { 'content-type': contentType } });
                    })();
                }
            }
        });
    </script>-->
</body>

</html>
